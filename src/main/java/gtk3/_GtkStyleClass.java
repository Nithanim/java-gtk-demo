// Generated by jextract

package gtk3;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class _GtkStyleClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            MemoryLayout.sequenceLayout(6, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("realize"),
        Constants$root.C_POINTER$LAYOUT.withName("unrealize"),
        Constants$root.C_POINTER$LAYOUT.withName("copy"),
        Constants$root.C_POINTER$LAYOUT.withName("clone"),
        Constants$root.C_POINTER$LAYOUT.withName("init_from_rc"),
        Constants$root.C_POINTER$LAYOUT.withName("set_background"),
        Constants$root.C_POINTER$LAYOUT.withName("render_icon"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_hline"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_vline"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_shadow"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_arrow"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_diamond"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_box"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_flat_box"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_check"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_option"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_tab"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_shadow_gap"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_box_gap"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_extension"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_focus"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_slider"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_handle"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_expander"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_layout"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_resize_grip"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_spinner"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved3"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved4"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved5"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved6"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved7"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved8"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved9"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved10"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved11")
    ).withName("_GtkStyleClass");
    public static MemoryLayout $LAYOUT() {
        return _GtkStyleClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor realize$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle realize$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.realize$FUNC, false
    );
    public interface realize {

        void apply(jdk.incubator.foreign.MemoryAddress _x0);
        static NativeSymbol allocate(realize fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(realize.class, fi, _GtkStyleClass.realize$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static realize ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("realize::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0) -> {
                try {
                    _GtkStyleClass.realize$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle realize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("realize"));
    public static VarHandle realize$VH() {
        return _GtkStyleClass.realize$VH;
    }
    public static MemoryAddress realize$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.realize$VH.get(seg);
    }
    public static void realize$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.realize$VH.set(seg, x);
    }
    public static MemoryAddress realize$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.realize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void realize$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.realize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static realize realize (MemorySegment segment, ResourceScope scope) {
        return realize.ofAddress(realize$get(segment), scope);
    }
    static final FunctionDescriptor unrealize$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unrealize$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.unrealize$FUNC, false
    );
    public interface unrealize {

        void apply(jdk.incubator.foreign.MemoryAddress _x0);
        static NativeSymbol allocate(unrealize fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(unrealize.class, fi, _GtkStyleClass.unrealize$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static unrealize ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("unrealize::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0) -> {
                try {
                    _GtkStyleClass.unrealize$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unrealize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unrealize"));
    public static VarHandle unrealize$VH() {
        return _GtkStyleClass.unrealize$VH;
    }
    public static MemoryAddress unrealize$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.unrealize$VH.get(seg);
    }
    public static void unrealize$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.unrealize$VH.set(seg, x);
    }
    public static MemoryAddress unrealize$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.unrealize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unrealize$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.unrealize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unrealize unrealize (MemorySegment segment, ResourceScope scope) {
        return unrealize.ofAddress(unrealize$get(segment), scope);
    }
    static final FunctionDescriptor copy$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle copy$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.copy$FUNC, false
    );
    public interface copy {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1);
        static NativeSymbol allocate(copy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(copy.class, fi, _GtkStyleClass.copy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static copy ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("copy::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1) -> {
                try {
                    _GtkStyleClass.copy$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy"));
    public static VarHandle copy$VH() {
        return _GtkStyleClass.copy$VH;
    }
    public static MemoryAddress copy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.copy$VH.get(seg);
    }
    public static void copy$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.copy$VH.set(seg, x);
    }
    public static MemoryAddress copy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.copy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.copy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy copy (MemorySegment segment, ResourceScope scope) {
        return copy.ofAddress(copy$get(segment), scope);
    }
    static final FunctionDescriptor clone$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle clone$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.clone$FUNC, false
    );
    public interface clone {

        jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress _x0);
        static NativeSymbol allocate(clone fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(clone.class, fi, _GtkStyleClass.clone$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/Addressable;", scope);
        }
        static clone ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("clone::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0) -> {
                try {
                    return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.clone$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle clone$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("clone"));
    public static VarHandle clone$VH() {
        return _GtkStyleClass.clone$VH;
    }
    public static MemoryAddress clone$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.clone$VH.get(seg);
    }
    public static void clone$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.clone$VH.set(seg, x);
    }
    public static MemoryAddress clone$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.clone$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void clone$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.clone$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static clone clone (MemorySegment segment, ResourceScope scope) {
        return clone.ofAddress(clone$get(segment), scope);
    }
    static final FunctionDescriptor init_from_rc$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle init_from_rc$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.init_from_rc$FUNC, false
    );
    public interface init_from_rc {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1);
        static NativeSymbol allocate(init_from_rc fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(init_from_rc.class, fi, _GtkStyleClass.init_from_rc$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static init_from_rc ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("init_from_rc::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1) -> {
                try {
                    _GtkStyleClass.init_from_rc$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init_from_rc$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init_from_rc"));
    public static VarHandle init_from_rc$VH() {
        return _GtkStyleClass.init_from_rc$VH;
    }
    public static MemoryAddress init_from_rc$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.init_from_rc$VH.get(seg);
    }
    public static void init_from_rc$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.init_from_rc$VH.set(seg, x);
    }
    public static MemoryAddress init_from_rc$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.init_from_rc$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init_from_rc$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.init_from_rc$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init_from_rc init_from_rc (MemorySegment segment, ResourceScope scope) {
        return init_from_rc.ofAddress(init_from_rc$get(segment), scope);
    }
    static final FunctionDescriptor set_background$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle set_background$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.set_background$FUNC, false
    );
    public interface set_background {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2);
        static NativeSymbol allocate(set_background fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(set_background.class, fi, _GtkStyleClass.set_background$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)V", scope);
        }
        static set_background ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("set_background::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2) -> {
                try {
                    _GtkStyleClass.set_background$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_background$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_background"));
    public static VarHandle set_background$VH() {
        return _GtkStyleClass.set_background$VH;
    }
    public static MemoryAddress set_background$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.set_background$VH.get(seg);
    }
    public static void set_background$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.set_background$VH.set(seg, x);
    }
    public static MemoryAddress set_background$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.set_background$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_background$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.set_background$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_background set_background (MemorySegment segment, ResourceScope scope) {
        return set_background.ofAddress(set_background$get(segment), scope);
    }
    static final FunctionDescriptor render_icon$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle render_icon$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.render_icon$FUNC, false
    );
    public interface render_icon {

        jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, int _x4, jdk.incubator.foreign.MemoryAddress _x5, jdk.incubator.foreign.MemoryAddress _x6);
        static NativeSymbol allocate(render_icon fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(render_icon.class, fi, _GtkStyleClass.render_icon$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/Addressable;", scope);
        }
        static render_icon ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("render_icon::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, int _x4, jdk.incubator.foreign.MemoryAddress _x5, jdk.incubator.foreign.MemoryAddress _x6) -> {
                try {
                    return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.render_icon$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, _x4, (jdk.incubator.foreign.Addressable)_x5, (jdk.incubator.foreign.Addressable)_x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle render_icon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("render_icon"));
    public static VarHandle render_icon$VH() {
        return _GtkStyleClass.render_icon$VH;
    }
    public static MemoryAddress render_icon$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.render_icon$VH.get(seg);
    }
    public static void render_icon$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.render_icon$VH.set(seg, x);
    }
    public static MemoryAddress render_icon$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.render_icon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void render_icon$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.render_icon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static render_icon render_icon (MemorySegment segment, ResourceScope scope) {
        return render_icon.ofAddress(render_icon$get(segment), scope);
    }
    static final FunctionDescriptor draw_hline$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_hline$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_hline$FUNC, false
    );
    public interface draw_hline {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static NativeSymbol allocate(draw_hline fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_hline.class, fi, _GtkStyleClass.draw_hline$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;III)V", scope);
        }
        static draw_hline ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_hline::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7) -> {
                try {
                    _GtkStyleClass.draw_hline$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_hline$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_hline"));
    public static VarHandle draw_hline$VH() {
        return _GtkStyleClass.draw_hline$VH;
    }
    public static MemoryAddress draw_hline$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_hline$VH.get(seg);
    }
    public static void draw_hline$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_hline$VH.set(seg, x);
    }
    public static MemoryAddress draw_hline$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_hline$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_hline$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_hline$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_hline draw_hline (MemorySegment segment, ResourceScope scope) {
        return draw_hline.ofAddress(draw_hline$get(segment), scope);
    }
    static final FunctionDescriptor draw_vline$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_vline$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_vline$FUNC, false
    );
    public interface draw_vline {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static NativeSymbol allocate(draw_vline fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_vline.class, fi, _GtkStyleClass.draw_vline$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;III)V", scope);
        }
        static draw_vline ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_vline::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7) -> {
                try {
                    _GtkStyleClass.draw_vline$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_vline$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_vline"));
    public static VarHandle draw_vline$VH() {
        return _GtkStyleClass.draw_vline$VH;
    }
    public static MemoryAddress draw_vline$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_vline$VH.get(seg);
    }
    public static void draw_vline$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_vline$VH.set(seg, x);
    }
    public static MemoryAddress draw_vline$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_vline$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_vline$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_vline$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_vline draw_vline (MemorySegment segment, ResourceScope scope) {
        return draw_vline.ofAddress(draw_vline$get(segment), scope);
    }
    static final FunctionDescriptor draw_shadow$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_shadow$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_shadow$FUNC, false
    );
    public interface draw_shadow {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_shadow fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_shadow.class, fi, _GtkStyleClass.draw_shadow$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_shadow ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_shadow::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_shadow$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_shadow$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_shadow"));
    public static VarHandle draw_shadow$VH() {
        return _GtkStyleClass.draw_shadow$VH;
    }
    public static MemoryAddress draw_shadow$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_shadow$VH.get(seg);
    }
    public static void draw_shadow$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_shadow$VH.set(seg, x);
    }
    public static MemoryAddress draw_shadow$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_shadow$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_shadow$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_shadow$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_shadow draw_shadow (MemorySegment segment, ResourceScope scope) {
        return draw_shadow.ofAddress(draw_shadow$get(segment), scope);
    }
    static final FunctionDescriptor draw_arrow$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_arrow$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_arrow$FUNC, false
    );
    public interface draw_arrow {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11);
        static NativeSymbol allocate(draw_arrow fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_arrow.class, fi, _GtkStyleClass.draw_arrow$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIIII)V", scope);
        }
        static draw_arrow ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_arrow::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11) -> {
                try {
                    _GtkStyleClass.draw_arrow$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10, _x11);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_arrow$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_arrow"));
    public static VarHandle draw_arrow$VH() {
        return _GtkStyleClass.draw_arrow$VH;
    }
    public static MemoryAddress draw_arrow$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_arrow$VH.get(seg);
    }
    public static void draw_arrow$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_arrow$VH.set(seg, x);
    }
    public static MemoryAddress draw_arrow$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_arrow$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_arrow$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_arrow$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_arrow draw_arrow (MemorySegment segment, ResourceScope scope) {
        return draw_arrow.ofAddress(draw_arrow$get(segment), scope);
    }
    static final FunctionDescriptor draw_diamond$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_diamond$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_diamond$FUNC, false
    );
    public interface draw_diamond {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_diamond fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_diamond.class, fi, _GtkStyleClass.draw_diamond$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_diamond ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_diamond::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_diamond$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_diamond$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_diamond"));
    public static VarHandle draw_diamond$VH() {
        return _GtkStyleClass.draw_diamond$VH;
    }
    public static MemoryAddress draw_diamond$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_diamond$VH.get(seg);
    }
    public static void draw_diamond$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_diamond$VH.set(seg, x);
    }
    public static MemoryAddress draw_diamond$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_diamond$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_diamond$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_diamond$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_diamond draw_diamond (MemorySegment segment, ResourceScope scope) {
        return draw_diamond.ofAddress(draw_diamond$get(segment), scope);
    }
    static final FunctionDescriptor draw_box$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_box$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_box$FUNC, false
    );
    public interface draw_box {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_box fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_box.class, fi, _GtkStyleClass.draw_box$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_box ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_box::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_box$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_box$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_box"));
    public static VarHandle draw_box$VH() {
        return _GtkStyleClass.draw_box$VH;
    }
    public static MemoryAddress draw_box$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_box$VH.get(seg);
    }
    public static void draw_box$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_box$VH.set(seg, x);
    }
    public static MemoryAddress draw_box$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_box$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_box$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_box$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_box draw_box (MemorySegment segment, ResourceScope scope) {
        return draw_box.ofAddress(draw_box$get(segment), scope);
    }
    static final FunctionDescriptor draw_flat_box$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_flat_box$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_flat_box$FUNC, false
    );
    public interface draw_flat_box {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_flat_box fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_flat_box.class, fi, _GtkStyleClass.draw_flat_box$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_flat_box ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_flat_box::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_flat_box$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_flat_box$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_flat_box"));
    public static VarHandle draw_flat_box$VH() {
        return _GtkStyleClass.draw_flat_box$VH;
    }
    public static MemoryAddress draw_flat_box$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_flat_box$VH.get(seg);
    }
    public static void draw_flat_box$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_flat_box$VH.set(seg, x);
    }
    public static MemoryAddress draw_flat_box$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_flat_box$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_flat_box$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_flat_box$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_flat_box draw_flat_box (MemorySegment segment, ResourceScope scope) {
        return draw_flat_box.ofAddress(draw_flat_box$get(segment), scope);
    }
    static final FunctionDescriptor draw_check$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_check$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_check$FUNC, false
    );
    public interface draw_check {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_check fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_check.class, fi, _GtkStyleClass.draw_check$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_check ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_check::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_check$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_check$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_check"));
    public static VarHandle draw_check$VH() {
        return _GtkStyleClass.draw_check$VH;
    }
    public static MemoryAddress draw_check$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_check$VH.get(seg);
    }
    public static void draw_check$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_check$VH.set(seg, x);
    }
    public static MemoryAddress draw_check$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_check$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_check$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_check$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_check draw_check (MemorySegment segment, ResourceScope scope) {
        return draw_check.ofAddress(draw_check$get(segment), scope);
    }
    static final FunctionDescriptor draw_option$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_option$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_option$FUNC, false
    );
    public interface draw_option {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_option fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_option.class, fi, _GtkStyleClass.draw_option$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_option ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_option::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_option$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_option$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_option"));
    public static VarHandle draw_option$VH() {
        return _GtkStyleClass.draw_option$VH;
    }
    public static MemoryAddress draw_option$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_option$VH.get(seg);
    }
    public static void draw_option$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_option$VH.set(seg, x);
    }
    public static MemoryAddress draw_option$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_option$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_option$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_option$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_option draw_option (MemorySegment segment, ResourceScope scope) {
        return draw_option.ofAddress(draw_option$get(segment), scope);
    }
    static final FunctionDescriptor draw_tab$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_tab$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_tab$FUNC, false
    );
    public interface draw_tab {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_tab fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_tab.class, fi, _GtkStyleClass.draw_tab$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_tab ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_tab::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_tab$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_tab$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_tab"));
    public static VarHandle draw_tab$VH() {
        return _GtkStyleClass.draw_tab$VH;
    }
    public static MemoryAddress draw_tab$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_tab$VH.get(seg);
    }
    public static void draw_tab$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_tab$VH.set(seg, x);
    }
    public static MemoryAddress draw_tab$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_tab$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_tab$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_tab$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_tab draw_tab (MemorySegment segment, ResourceScope scope) {
        return draw_tab.ofAddress(draw_tab$get(segment), scope);
    }
    static final FunctionDescriptor draw_shadow_gap$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_shadow_gap$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_shadow_gap$FUNC, false
    );
    public interface draw_shadow_gap {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12);
        static NativeSymbol allocate(draw_shadow_gap fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_shadow_gap.class, fi, _GtkStyleClass.draw_shadow_gap$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIIIII)V", scope);
        }
        static draw_shadow_gap ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_shadow_gap::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12) -> {
                try {
                    _GtkStyleClass.draw_shadow_gap$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_shadow_gap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_shadow_gap"));
    public static VarHandle draw_shadow_gap$VH() {
        return _GtkStyleClass.draw_shadow_gap$VH;
    }
    public static MemoryAddress draw_shadow_gap$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_shadow_gap$VH.get(seg);
    }
    public static void draw_shadow_gap$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_shadow_gap$VH.set(seg, x);
    }
    public static MemoryAddress draw_shadow_gap$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_shadow_gap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_shadow_gap$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_shadow_gap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_shadow_gap draw_shadow_gap (MemorySegment segment, ResourceScope scope) {
        return draw_shadow_gap.ofAddress(draw_shadow_gap$get(segment), scope);
    }
    static final FunctionDescriptor draw_box_gap$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_box_gap$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_box_gap$FUNC, false
    );
    public interface draw_box_gap {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12);
        static NativeSymbol allocate(draw_box_gap fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_box_gap.class, fi, _GtkStyleClass.draw_box_gap$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIIIII)V", scope);
        }
        static draw_box_gap ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_box_gap::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12) -> {
                try {
                    _GtkStyleClass.draw_box_gap$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_box_gap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_box_gap"));
    public static VarHandle draw_box_gap$VH() {
        return _GtkStyleClass.draw_box_gap$VH;
    }
    public static MemoryAddress draw_box_gap$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_box_gap$VH.get(seg);
    }
    public static void draw_box_gap$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_box_gap$VH.set(seg, x);
    }
    public static MemoryAddress draw_box_gap$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_box_gap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_box_gap$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_box_gap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_box_gap draw_box_gap (MemorySegment segment, ResourceScope scope) {
        return draw_box_gap.ofAddress(draw_box_gap$get(segment), scope);
    }
    static final FunctionDescriptor draw_extension$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_extension$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_extension$FUNC, false
    );
    public interface draw_extension {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static NativeSymbol allocate(draw_extension fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_extension.class, fi, _GtkStyleClass.draw_extension$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIII)V", scope);
        }
        static draw_extension ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_extension::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10) -> {
                try {
                    _GtkStyleClass.draw_extension$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_extension$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_extension"));
    public static VarHandle draw_extension$VH() {
        return _GtkStyleClass.draw_extension$VH;
    }
    public static MemoryAddress draw_extension$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_extension$VH.get(seg);
    }
    public static void draw_extension$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_extension$VH.set(seg, x);
    }
    public static MemoryAddress draw_extension$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_extension$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_extension$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_extension$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_extension draw_extension (MemorySegment segment, ResourceScope scope) {
        return draw_extension.ofAddress(draw_extension$get(segment), scope);
    }
    static final FunctionDescriptor draw_focus$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_focus$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_focus$FUNC, false
    );
    public interface draw_focus {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8);
        static NativeSymbol allocate(draw_focus fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_focus.class, fi, _GtkStyleClass.draw_focus$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIII)V", scope);
        }
        static draw_focus ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_focus::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8) -> {
                try {
                    _GtkStyleClass.draw_focus$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7, _x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_focus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_focus"));
    public static VarHandle draw_focus$VH() {
        return _GtkStyleClass.draw_focus$VH;
    }
    public static MemoryAddress draw_focus$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_focus$VH.get(seg);
    }
    public static void draw_focus$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_focus$VH.set(seg, x);
    }
    public static MemoryAddress draw_focus$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_focus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_focus$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_focus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_focus draw_focus (MemorySegment segment, ResourceScope scope) {
        return draw_focus.ofAddress(draw_focus$get(segment), scope);
    }
    static final FunctionDescriptor draw_slider$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_slider$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_slider$FUNC, false
    );
    public interface draw_slider {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static NativeSymbol allocate(draw_slider fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_slider.class, fi, _GtkStyleClass.draw_slider$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIII)V", scope);
        }
        static draw_slider ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_slider::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10) -> {
                try {
                    _GtkStyleClass.draw_slider$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_slider$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_slider"));
    public static VarHandle draw_slider$VH() {
        return _GtkStyleClass.draw_slider$VH;
    }
    public static MemoryAddress draw_slider$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_slider$VH.get(seg);
    }
    public static void draw_slider$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_slider$VH.set(seg, x);
    }
    public static MemoryAddress draw_slider$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_slider$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_slider$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_slider$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_slider draw_slider (MemorySegment segment, ResourceScope scope) {
        return draw_slider.ofAddress(draw_slider$get(segment), scope);
    }
    static final FunctionDescriptor draw_handle$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_handle$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_handle$FUNC, false
    );
    public interface draw_handle {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static NativeSymbol allocate(draw_handle fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_handle.class, fi, _GtkStyleClass.draw_handle$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIII)V", scope);
        }
        static draw_handle ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_handle::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10) -> {
                try {
                    _GtkStyleClass.draw_handle$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, _x8, _x9, _x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_handle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_handle"));
    public static VarHandle draw_handle$VH() {
        return _GtkStyleClass.draw_handle$VH;
    }
    public static MemoryAddress draw_handle$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_handle$VH.get(seg);
    }
    public static void draw_handle$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_handle$VH.set(seg, x);
    }
    public static MemoryAddress draw_handle$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_handle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_handle$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_handle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_handle draw_handle (MemorySegment segment, ResourceScope scope) {
        return draw_handle.ofAddress(draw_handle$get(segment), scope);
    }
    static final FunctionDescriptor draw_expander$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_expander$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_expander$FUNC, false
    );
    public interface draw_expander {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static NativeSymbol allocate(draw_expander fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_expander.class, fi, _GtkStyleClass.draw_expander$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;III)V", scope);
        }
        static draw_expander ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_expander::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7) -> {
                try {
                    _GtkStyleClass.draw_expander$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_expander$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_expander"));
    public static VarHandle draw_expander$VH() {
        return _GtkStyleClass.draw_expander$VH;
    }
    public static MemoryAddress draw_expander$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_expander$VH.get(seg);
    }
    public static void draw_expander$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_expander$VH.set(seg, x);
    }
    public static MemoryAddress draw_expander$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_expander$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_expander$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_expander$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_expander draw_expander (MemorySegment segment, ResourceScope scope) {
        return draw_expander.ofAddress(draw_expander$get(segment), scope);
    }
    static final FunctionDescriptor draw_layout$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle draw_layout$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_layout$FUNC, false
    );
    public interface draw_layout {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, jdk.incubator.foreign.MemoryAddress _x8);
        static NativeSymbol allocate(draw_layout fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_layout.class, fi, _GtkStyleClass.draw_layout$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static draw_layout ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_layout::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, int _x3, jdk.incubator.foreign.MemoryAddress _x4, jdk.incubator.foreign.MemoryAddress _x5, int _x6, int _x7, jdk.incubator.foreign.MemoryAddress _x8) -> {
                try {
                    _GtkStyleClass.draw_layout$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, _x3, (jdk.incubator.foreign.Addressable)_x4, (jdk.incubator.foreign.Addressable)_x5, _x6, _x7, (jdk.incubator.foreign.Addressable)_x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_layout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_layout"));
    public static VarHandle draw_layout$VH() {
        return _GtkStyleClass.draw_layout$VH;
    }
    public static MemoryAddress draw_layout$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_layout$VH.get(seg);
    }
    public static void draw_layout$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_layout$VH.set(seg, x);
    }
    public static MemoryAddress draw_layout$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_layout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_layout$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_layout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_layout draw_layout (MemorySegment segment, ResourceScope scope) {
        return draw_layout.ofAddress(draw_layout$get(segment), scope);
    }
    static final FunctionDescriptor draw_resize_grip$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_resize_grip$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_resize_grip$FUNC, false
    );
    public interface draw_resize_grip {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_resize_grip fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_resize_grip.class, fi, _GtkStyleClass.draw_resize_grip$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIII)V", scope);
        }
        static draw_resize_grip ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_resize_grip::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_resize_grip$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_resize_grip$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_resize_grip"));
    public static VarHandle draw_resize_grip$VH() {
        return _GtkStyleClass.draw_resize_grip$VH;
    }
    public static MemoryAddress draw_resize_grip$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_resize_grip$VH.get(seg);
    }
    public static void draw_resize_grip$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_resize_grip$VH.set(seg, x);
    }
    public static MemoryAddress draw_resize_grip$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_resize_grip$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_resize_grip$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_resize_grip$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_resize_grip draw_resize_grip (MemorySegment segment, ResourceScope scope) {
        return draw_resize_grip.ofAddress(draw_resize_grip$get(segment), scope);
    }
    static final FunctionDescriptor draw_spinner$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_spinner$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_spinner$FUNC, false
    );
    public interface draw_spinner {

        void apply(jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9);
        static NativeSymbol allocate(draw_spinner fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(draw_spinner.class, fi, _GtkStyleClass.draw_spinner$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIIII)V", scope);
        }
        static draw_spinner ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("draw_spinner::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress _x0, jdk.incubator.foreign.MemoryAddress _x1, int _x2, jdk.incubator.foreign.MemoryAddress _x3, jdk.incubator.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9) -> {
                try {
                    _GtkStyleClass.draw_spinner$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)_x0, (jdk.incubator.foreign.Addressable)_x1, _x2, (jdk.incubator.foreign.Addressable)_x3, (jdk.incubator.foreign.Addressable)_x4, _x5, _x6, _x7, _x8, _x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_spinner$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_spinner"));
    public static VarHandle draw_spinner$VH() {
        return _GtkStyleClass.draw_spinner$VH;
    }
    public static MemoryAddress draw_spinner$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_spinner$VH.get(seg);
    }
    public static void draw_spinner$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_spinner$VH.set(seg, x);
    }
    public static MemoryAddress draw_spinner$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass.draw_spinner$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_spinner$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_spinner$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_spinner draw_spinner (MemorySegment segment, ResourceScope scope) {
        return draw_spinner.ofAddress(draw_spinner$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved1$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved1$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved1$FUNC, false
    );
    public interface _gtk_reserved1 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved1 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved1.class, fi, _GtkStyleClass._gtk_reserved1$FUNC, "()V", scope);
        }
        static _gtk_reserved1 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved1::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved1$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved1"));
    public static VarHandle _gtk_reserved1$VH() {
        return _GtkStyleClass._gtk_reserved1$VH;
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved1$VH.get(seg);
    }
    public static void _gtk_reserved1$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved1$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved1 _gtk_reserved1 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved1.ofAddress(_gtk_reserved1$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved2$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved2$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved2$FUNC, false
    );
    public interface _gtk_reserved2 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved2 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved2.class, fi, _GtkStyleClass._gtk_reserved2$FUNC, "()V", scope);
        }
        static _gtk_reserved2 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved2::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved2$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved2"));
    public static VarHandle _gtk_reserved2$VH() {
        return _GtkStyleClass._gtk_reserved2$VH;
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved2$VH.get(seg);
    }
    public static void _gtk_reserved2$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved2$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved2 _gtk_reserved2 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved2.ofAddress(_gtk_reserved2$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved3$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved3$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved3$FUNC, false
    );
    public interface _gtk_reserved3 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved3 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved3.class, fi, _GtkStyleClass._gtk_reserved3$FUNC, "()V", scope);
        }
        static _gtk_reserved3 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved3::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved3$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved3"));
    public static VarHandle _gtk_reserved3$VH() {
        return _GtkStyleClass._gtk_reserved3$VH;
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved3$VH.get(seg);
    }
    public static void _gtk_reserved3$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved3$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved3$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved3 _gtk_reserved3 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved3.ofAddress(_gtk_reserved3$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved4$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved4$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved4$FUNC, false
    );
    public interface _gtk_reserved4 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved4 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved4.class, fi, _GtkStyleClass._gtk_reserved4$FUNC, "()V", scope);
        }
        static _gtk_reserved4 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved4::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved4$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved4$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved4"));
    public static VarHandle _gtk_reserved4$VH() {
        return _GtkStyleClass._gtk_reserved4$VH;
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved4$VH.get(seg);
    }
    public static void _gtk_reserved4$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved4$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved4$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved4$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved4$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved4 _gtk_reserved4 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved4.ofAddress(_gtk_reserved4$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved5$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved5$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved5$FUNC, false
    );
    public interface _gtk_reserved5 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved5 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved5.class, fi, _GtkStyleClass._gtk_reserved5$FUNC, "()V", scope);
        }
        static _gtk_reserved5 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved5::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved5$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved5$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved5"));
    public static VarHandle _gtk_reserved5$VH() {
        return _GtkStyleClass._gtk_reserved5$VH;
    }
    public static MemoryAddress _gtk_reserved5$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved5$VH.get(seg);
    }
    public static void _gtk_reserved5$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved5$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved5$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved5$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved5$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved5$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved5 _gtk_reserved5 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved5.ofAddress(_gtk_reserved5$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved6$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved6$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved6$FUNC, false
    );
    public interface _gtk_reserved6 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved6 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved6.class, fi, _GtkStyleClass._gtk_reserved6$FUNC, "()V", scope);
        }
        static _gtk_reserved6 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved6::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved6$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved6$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved6"));
    public static VarHandle _gtk_reserved6$VH() {
        return _GtkStyleClass._gtk_reserved6$VH;
    }
    public static MemoryAddress _gtk_reserved6$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved6$VH.get(seg);
    }
    public static void _gtk_reserved6$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved6$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved6$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved6$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved6$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved6$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved6 _gtk_reserved6 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved6.ofAddress(_gtk_reserved6$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved7$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved7$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved7$FUNC, false
    );
    public interface _gtk_reserved7 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved7 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved7.class, fi, _GtkStyleClass._gtk_reserved7$FUNC, "()V", scope);
        }
        static _gtk_reserved7 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved7::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved7$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved7$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved7"));
    public static VarHandle _gtk_reserved7$VH() {
        return _GtkStyleClass._gtk_reserved7$VH;
    }
    public static MemoryAddress _gtk_reserved7$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved7$VH.get(seg);
    }
    public static void _gtk_reserved7$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved7$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved7$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved7$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved7$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved7$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved7 _gtk_reserved7 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved7.ofAddress(_gtk_reserved7$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved8$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved8$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved8$FUNC, false
    );
    public interface _gtk_reserved8 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved8 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved8.class, fi, _GtkStyleClass._gtk_reserved8$FUNC, "()V", scope);
        }
        static _gtk_reserved8 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved8::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved8$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved8$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved8"));
    public static VarHandle _gtk_reserved8$VH() {
        return _GtkStyleClass._gtk_reserved8$VH;
    }
    public static MemoryAddress _gtk_reserved8$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved8$VH.get(seg);
    }
    public static void _gtk_reserved8$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved8$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved8$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved8$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved8$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved8$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved8 _gtk_reserved8 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved8.ofAddress(_gtk_reserved8$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved9$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved9$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved9$FUNC, false
    );
    public interface _gtk_reserved9 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved9 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved9.class, fi, _GtkStyleClass._gtk_reserved9$FUNC, "()V", scope);
        }
        static _gtk_reserved9 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved9::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved9$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved9$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved9"));
    public static VarHandle _gtk_reserved9$VH() {
        return _GtkStyleClass._gtk_reserved9$VH;
    }
    public static MemoryAddress _gtk_reserved9$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved9$VH.get(seg);
    }
    public static void _gtk_reserved9$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved9$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved9$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved9$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved9$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved9$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved9 _gtk_reserved9 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved9.ofAddress(_gtk_reserved9$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved10$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved10$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved10$FUNC, false
    );
    public interface _gtk_reserved10 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved10 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved10.class, fi, _GtkStyleClass._gtk_reserved10$FUNC, "()V", scope);
        }
        static _gtk_reserved10 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved10::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved10$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved10$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved10"));
    public static VarHandle _gtk_reserved10$VH() {
        return _GtkStyleClass._gtk_reserved10$VH;
    }
    public static MemoryAddress _gtk_reserved10$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved10$VH.get(seg);
    }
    public static void _gtk_reserved10$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved10$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved10$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved10$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved10$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved10$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved10 _gtk_reserved10 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved10.ofAddress(_gtk_reserved10$get(segment), scope);
    }
    static final FunctionDescriptor _gtk_reserved11$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved11$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved11$FUNC, false
    );
    public interface _gtk_reserved11 {

        void apply();
        static NativeSymbol allocate(_gtk_reserved11 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(_gtk_reserved11.class, fi, _GtkStyleClass._gtk_reserved11$FUNC, "()V", scope);
        }
        static _gtk_reserved11 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("_gtk_reserved11::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GtkStyleClass._gtk_reserved11$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved11$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved11"));
    public static VarHandle _gtk_reserved11$VH() {
        return _GtkStyleClass._gtk_reserved11$VH;
    }
    public static MemoryAddress _gtk_reserved11$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved11$VH.get(seg);
    }
    public static void _gtk_reserved11$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved11$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved11$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved11$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved11$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved11$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved11 _gtk_reserved11 (MemorySegment segment, ResourceScope scope) {
        return _gtk_reserved11.ofAddress(_gtk_reserved11$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


